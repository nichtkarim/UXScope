"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/aggregatedExport.ts":
/*!*************************************!*\
  !*** ./src/lib/aggregatedExport.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CrossSurfaceAnalyzer: () => (/* binding */ CrossSurfaceAnalyzer),\n/* harmony export */   createAggregatedExcelWorkbook: () => (/* binding */ createAggregatedExcelWorkbook),\n/* harmony export */   exportAggregatedExcel: () => (/* binding */ exportAggregatedExcel)\n/* harmony export */ });\n/* harmony import */ var xlsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! xlsx */ \"(app-pages-browser)/./node_modules/xlsx/xlsx.mjs\");\n/* harmony import */ var _projectManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./projectManager */ \"(app-pages-browser)/./src/lib/projectManager.ts\");\n// 🎯 Aggregated Excel Export - Multi-Surface Analysis Aggregator (MSAA)\n// Exportiert mehrere Analysen eines Projekts in einem umfassenden Excel-File\n\n\n// 🧠 Cross-Surface Analysis Engine\nclass CrossSurfaceAnalyzer {\n    static analyzeProject(projectId) {\n        var _dates_, _dates_1;\n        const project = _projectManager__WEBPACK_IMPORTED_MODULE_0__.ProjectManager.getProject(projectId);\n        const analyses = _projectManager__WEBPACK_IMPORTED_MODULE_0__.ProjectManager.getAnalysesByProject(projectId);\n        if (!project || analyses.length === 0) {\n            throw new Error(\"Projekt \".concat(projectId, \" nicht gefunden oder leer\"));\n        }\n        console.log('\\uD83D\\uDD0D Analysiere Projekt \"'.concat(project.projectName, '\" mit ').concat(analyses.length, \" Analysen...\"));\n        // Cross-Surface Analysis durchführen\n        const crossAnalysis = this.performCrossSurfaceAnalysis(analyses);\n        const projectStats = this.calculateProjectStats(analyses);\n        // Datum-Range ermitteln\n        const dates = analyses.map((a)=>a.createdAt).sort((a, b)=>a.getTime() - b.getTime());\n        const dateRange = {\n            earliest: ((_dates_ = dates[0]) === null || _dates_ === void 0 ? void 0 : _dates_.toLocaleDateString('de-DE')) || 'Unbekannt',\n            latest: ((_dates_1 = dates[dates.length - 1]) === null || _dates_1 === void 0 ? void 0 : _dates_1.toLocaleDateString('de-DE')) || 'Unbekannt'\n        };\n        const exportId = \"AGG_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substring(2, 8)).toUpperCase();\n        return {\n            projectInfo: {\n                projectId: project.projectId,\n                projectName: project.projectName,\n                projectDescription: project.projectDescription,\n                totalAnalyses: analyses.length,\n                dateRange,\n                exportDate: new Date().toLocaleDateString('de-DE'),\n                exportId\n            },\n            analyses,\n            crossSurfaceAnalysis: crossAnalysis,\n            projectStats\n        };\n    }\n    static performCrossSurfaceAnalysis(analyses) {\n        const allBefunde = analyses.flatMap((analysis)=>analysis.analysisData.befunde.map((befund)=>({\n                    ...befund,\n                    surfaceName: analysis.surfaceName,\n                    surfaceType: analysis.surfaceType,\n                    analysisId: analysis.analysisId\n                })));\n        // Häufige Probleme erkennen (basierend auf ähnlichen Titeln/Beschreibungen)\n        const commonProblems = this.detectCommonProblems(allBefunde);\n        // Schweregrad-Verteilung\n        const severityDistribution = allBefunde.reduce((acc, befund)=>{\n            acc[befund.schweregrad] = (acc[befund.schweregrad] || 0) + 1;\n            return acc;\n        }, {});\n        // Oberflächen-Vergleich\n        const surfaceComparison = this.compareSurfaces(analyses);\n        // Trends (vereinfacht - basierend auf Chronologie)\n        const trends = this.analyzeTrends(analyses);\n        return {\n            totalBefunde: allBefunde.length,\n            commonProblems,\n            severityDistribution,\n            surfaceComparison,\n            trends\n        };\n    }\n    static detectCommonProblems(befunde) {\n        // Gruppiere ähnliche Probleme basierend auf Keywords in Titel/Beschreibung\n        const problemGroups = {};\n        const keywords = [\n            'navigation',\n            'button',\n            'text',\n            'color',\n            'contrast',\n            'layout',\n            'mobile',\n            'responsive',\n            'accessibility',\n            'loading',\n            'error',\n            'form',\n            'validation',\n            'usability',\n            'user',\n            'interface',\n            'design',\n            'functionality'\n        ];\n        befunde.forEach((befund)=>{\n            const text = \"\".concat(befund.titel, \" \").concat(befund.beschreibung).toLowerCase();\n            // Finde relevante Keywords\n            const foundKeywords = keywords.filter((keyword)=>text.includes(keyword));\n            if (foundKeywords.length > 0) {\n                const primaryKeyword = foundKeywords[0]; // Nehme das erste gefundene Keyword\n                if (!problemGroups[primaryKeyword]) {\n                    problemGroups[primaryKeyword] = [];\n                }\n                problemGroups[primaryKeyword].push(befund);\n            }\n        });\n        // Konvertiere zu common problems Format\n        return Object.entries(problemGroups).filter((param)=>{\n            let [, group] = param;\n            return group.length > 1;\n        }) // Nur Probleme die mehrfach auftreten\n        .map((param)=>{\n            let [keyword, group] = param;\n            return {\n                problem: \"\".concat(keyword.charAt(0).toUpperCase() + keyword.slice(1), \"-bezogene Probleme\"),\n                occurrences: group.length,\n                surfaces: [\n                    ...new Set(group.map((b)=>b.surfaceName))\n                ],\n                severity: this.getMostCommonSeverity(group)\n            };\n        }).sort((a, b)=>b.occurrences - a.occurrences).slice(0, 10); // Top 10 häufigste Probleme\n    }\n    static getMostCommonSeverity(befunde) {\n        var _Object_entries_sort_;\n        const severityCounts = befunde.reduce((acc, b)=>{\n            acc[b.schweregrad] = (acc[b.schweregrad] || 0) + 1;\n            return acc;\n        }, {});\n        return ((_Object_entries_sort_ = Object.entries(severityCounts).sort((param, param1)=>{\n            let [, a] = param, [, b] = param1;\n            return b - a;\n        })[0]) === null || _Object_entries_sort_ === void 0 ? void 0 : _Object_entries_sort_[0]) || 'unknown';\n    }\n    static compareSurfaces(analyses) {\n        return analyses.map((analysis)=>{\n            const befunde = analysis.analysisData.befunde;\n            const criticalIssues = befunde.filter((b)=>[\n                    'critical',\n                    'catastrophic',\n                    'serious'\n                ].includes(b.schweregrad)).length;\n            // Durchschnittlicher Schweregrad (vereinfacht)\n            const severityScores = {\n                'catastrophic': 5,\n                'critical': 4,\n                'serious': 3,\n                'minor': 2,\n                'positive': 1,\n                'Nicht bewertet': 0\n            };\n            const avgScore = befunde.length > 0 ? befunde.reduce((sum, b)=>sum + (severityScores[b.schweregrad] || 0), 0) / befunde.length : 0;\n            const avgSeverity = avgScore >= 4 ? 'Hoch' : avgScore >= 2.5 ? 'Mittel' : 'Niedrig';\n            return {\n                surfaceName: analysis.surfaceName,\n                surfaceType: analysis.surfaceType,\n                befundeCount: befunde.length,\n                criticalIssues,\n                averageSeverity: avgSeverity\n            };\n        });\n    }\n    static analyzeTrends(analyses) {\n        // Sortiere Analysen chronologisch\n        const sortedAnalyses = [\n            ...analyses\n        ].sort((a, b)=>a.createdAt.getTime() - b.createdAt.getTime());\n        // Vereinfachte Trend-Analyse basierend auf Anzahl kritischer Probleme über Zeit\n        const improvingAreas = [];\n        const worseningAreas = [];\n        if (sortedAnalyses.length >= 2) {\n            const early = sortedAnalyses.slice(0, Math.ceil(sortedAnalyses.length / 2));\n            const recent = sortedAnalyses.slice(Math.floor(sortedAnalyses.length / 2));\n            const earlyCritical = early.reduce((sum, a)=>sum + a.analysisData.befunde.filter((b)=>[\n                        'critical',\n                        'catastrophic'\n                    ].includes(b.schweregrad)).length, 0) / early.length;\n            const recentCritical = recent.reduce((sum, a)=>sum + a.analysisData.befunde.filter((b)=>[\n                        'critical',\n                        'catastrophic'\n                    ].includes(b.schweregrad)).length, 0) / recent.length;\n            if (recentCritical < earlyCritical) {\n                improvingAreas.push('Kritische Probleme reduziert');\n            } else if (recentCritical > earlyCritical) {\n                worseningAreas.push('Kritische Probleme gestiegen');\n            }\n        }\n        return {\n            improvingAreas,\n            worseningAreas\n        };\n    }\n    static calculateProjectStats(analyses) {\n        const promptVariants = [\n            ...new Set(analyses.map((a)=>a.analysisData.promptVariante))\n        ];\n        const llmModels = [\n            ...new Set(analyses.map((a)=>a.analysisData.llmModell))\n        ];\n        const surfaceTypes = analyses.reduce((acc, a)=>{\n            acc[a.surfaceType] = (acc[a.surfaceType] || 0) + 1;\n            return acc;\n        }, {});\n        const surfaceCategories = analyses.reduce((acc, a)=>{\n            acc[a.surfaceCategory] = (acc[a.surfaceCategory] || 0) + 1;\n            return acc;\n        }, {});\n        const totalProcessingTime = analyses.reduce((sum, a)=>sum + a.analysisData.verarbeitungszeit, 0);\n        const totalBefunde = analyses.reduce((sum, a)=>sum + a.analysisData.befunde.length, 0);\n        const analysisEfficiency = totalProcessingTime > 0 ? Math.round(totalBefunde / (totalProcessingTime / 60000) * 100) / 100 // Befunde pro Minute\n         : 0;\n        return {\n            promptVariantsUsed: promptVariants,\n            llmModelsUsed: llmModels,\n            surfaceTypes,\n            surfaceCategories,\n            totalProcessingTime,\n            analysisEfficiency\n        };\n    }\n}\n// 📊 Aggregated Excel Workbook Creator\nfunction createAggregatedExcelWorkbook(data) {\n    console.log('\\uD83D\\uDCCA Erstelle Aggregated Excel f\\xfcr Projekt \"'.concat(data.projectInfo.projectName, '\"...'));\n    const workbook = xlsx__WEBPACK_IMPORTED_MODULE_1__.utils.book_new();\n    // === 1. PROJEKT-ÜBERSICHT ===\n    const overviewData = [\n        [\n            'PROJEKT-ANALYSE ÜBERSICHT'\n        ],\n        [\n            ''\n        ],\n        [\n            'PROJEKT-INFORMATIONEN'\n        ],\n        [\n            'Projektname',\n            data.projectInfo.projectName\n        ],\n        [\n            'Projekt ID',\n            data.projectInfo.projectId\n        ],\n        [\n            'Beschreibung',\n            data.projectInfo.projectDescription || 'Keine Beschreibung'\n        ],\n        [\n            'Export-Datum',\n            data.projectInfo.exportDate\n        ],\n        [\n            'Export-ID',\n            data.projectInfo.exportId\n        ],\n        [\n            ''\n        ],\n        [\n            'ANALYSE-STATISTIKEN'\n        ],\n        [\n            'Gesamtanzahl Analysen',\n            data.projectInfo.totalAnalyses\n        ],\n        [\n            'Gesamtanzahl Befunde',\n            data.crossSurfaceAnalysis.totalBefunde\n        ],\n        [\n            'Zeitraum (von)',\n            data.projectInfo.dateRange.earliest\n        ],\n        [\n            'Zeitraum (bis)',\n            data.projectInfo.dateRange.latest\n        ],\n        [\n            ''\n        ],\n        [\n            'EFFIZIENZ-METRIKEN'\n        ],\n        [\n            'Gesamte Verarbeitungszeit (ms)',\n            data.projectStats.totalProcessingTime\n        ],\n        [\n            'Analyse-Effizienz (Befunde/Min)',\n            data.projectStats.analysisEfficiency\n        ],\n        [\n            'Ø Befunde pro Analyse',\n            Math.round(data.crossSurfaceAnalysis.totalBefunde / data.projectInfo.totalAnalyses * 100) / 100\n        ],\n        [\n            ''\n        ],\n        [\n            'VERWENDETE TECHNOLOGIEN'\n        ],\n        [\n            'Prompt-Varianten',\n            data.projectStats.promptVariantsUsed.join(', ')\n        ],\n        [\n            'LLM-Modelle',\n            data.projectStats.llmModelsUsed.join(', ')\n        ]\n    ];\n    const overviewWS = xlsx__WEBPACK_IMPORTED_MODULE_1__.utils.aoa_to_sheet(overviewData);\n    overviewWS['!cols'] = [\n        {\n            wch: 30\n        },\n        {\n            wch: 60\n        }\n    ];\n    xlsx__WEBPACK_IMPORTED_MODULE_1__.utils.book_append_sheet(workbook, overviewWS, '📊 Projekt-Übersicht');\n    // === 2. PROJEKT-KONTEXT (NEU) ===\n    const contextData = [\n        [\n            'PROJEKT-KONTEXT & EINGABEN'\n        ],\n        [\n            ''\n        ],\n        [\n            'KONTEXT-INFORMATIONEN AUS ALLEN ANALYSEN'\n        ]\n    ];\n    // Sammle alle einzigartigen Kontext-Informationen\n    const allAppOverviews = [\n        ...new Set(data.analyses.map((a)=>a.analysisData.appOverview).filter(Boolean))\n    ];\n    const allUserTasks = [\n        ...new Set(data.analyses.map((a)=>a.analysisData.benutzerAufgabe).filter(Boolean))\n    ];\n    const allCodeInputs = [\n        ...new Set(data.analyses.map((a)=>a.analysisData.eingegebenerCode).filter((code)=>code && code !== 'Kein Code eingegeben'))\n    ];\n    // App-Übersichten hinzufügen\n    if (allAppOverviews.length > 0) {\n        contextData.push([\n            ''\n        ], [\n            'APP-ÜBERSICHTEN'\n        ]);\n        allAppOverviews.forEach((overview, index)=>{\n            contextData.push([\n                \"App-\\xdcbersicht \".concat(index + 1),\n                overview\n            ]);\n        });\n    }\n    // Benutzeraufgaben hinzufügen\n    if (allUserTasks.length > 0) {\n        contextData.push([\n            ''\n        ], [\n            'BENUTZERAUFGABEN'\n        ]);\n        allUserTasks.forEach((task, index)=>{\n            contextData.push([\n                \"Benutzeraufgabe \".concat(index + 1),\n                task\n            ]);\n        });\n    }\n    // Code-Eingaben hinzufügen\n    if (allCodeInputs.length > 0) {\n        contextData.push([\n            ''\n        ], [\n            'QUELLCODE-EINGABEN'\n        ]);\n        allCodeInputs.forEach((code, index)=>{\n            contextData.push([\n                \"Code-Eingabe \".concat(index + 1),\n                code\n            ]);\n        });\n    }\n    // Falls keine Kontextdaten vorhanden\n    if (allAppOverviews.length === 0 && allUserTasks.length === 0 && allCodeInputs.length === 0) {\n        contextData.push([\n            ''\n        ], [\n            'Hinweis',\n            'Keine spezifischen Kontext-Eingaben in den Analysen gefunden.'\n        ]);\n    }\n    const contextWS = xlsx__WEBPACK_IMPORTED_MODULE_1__.utils.aoa_to_sheet(contextData);\n    contextWS['!cols'] = [\n        {\n            wch: 25\n        },\n        {\n            wch: 100\n        }\n    ]; // Label-Spalte und breite Inhalt-Spalte\n    xlsx__WEBPACK_IMPORTED_MODULE_1__.utils.book_append_sheet(workbook, contextWS, '📋 Projekt-Kontext');\n    // === 3. CROSS-SURFACE ANALYSE ===\n    const crossData = [\n        [\n            'CROSS-SURFACE ANALYSE'\n        ],\n        [\n            ''\n        ],\n        [\n            'HÄUFIGE PROBLEME ÜBER ALLE OBERFLÄCHEN'\n        ],\n        [\n            'Problem-Typ',\n            'Häufigkeit',\n            'Betroffene Oberflächen',\n            'Häufigster Schweregrad'\n        ]\n    ];\n    data.crossSurfaceAnalysis.commonProblems.forEach((problem)=>{\n        crossData.push([\n            problem.problem,\n            problem.occurrences.toString(),\n            problem.surfaces.join(', '),\n            problem.severity\n        ]);\n    });\n    crossData.push([\n        ''\n    ], [\n        'SCHWEREGRAD-VERTEILUNG (GESAMT)'\n    ], [\n        'Schweregrad',\n        'Anzahl',\n        'Prozent'\n    ]);\n    const totalBefunde = data.crossSurfaceAnalysis.totalBefunde;\n    Object.entries(data.crossSurfaceAnalysis.severityDistribution).forEach((param)=>{\n        let [severity, count] = param;\n        const percent = totalBefunde > 0 ? (count / totalBefunde * 100).toFixed(1) : '0';\n        crossData.push([\n            severity,\n            count.toString(),\n            \"\".concat(percent, \"%\")\n        ]);\n    });\n    const crossWS = xlsx__WEBPACK_IMPORTED_MODULE_1__.utils.aoa_to_sheet(crossData);\n    crossWS['!cols'] = [\n        {\n            wch: 30\n        },\n        {\n            wch: 15\n        },\n        {\n            wch: 40\n        },\n        {\n            wch: 20\n        }\n    ];\n    xlsx__WEBPACK_IMPORTED_MODULE_1__.utils.book_append_sheet(workbook, crossWS, '🔍 Cross-Surface Analyse');\n    // === 4. OBERFLÄCHEN-VERGLEICH ===\n    const comparisonData = [\n        [\n            'OBERFLÄCHEN-VERGLEICH'\n        ],\n        [\n            ''\n        ],\n        [\n            'Oberfläche',\n            'Typ',\n            'Befunde (Gesamt)',\n            'Kritische Probleme',\n            'Ø Schweregrad'\n        ]\n    ];\n    data.crossSurfaceAnalysis.surfaceComparison.forEach((surface)=>{\n        comparisonData.push([\n            surface.surfaceName,\n            surface.surfaceType,\n            surface.befundeCount.toString(),\n            surface.criticalIssues.toString(),\n            surface.averageSeverity\n        ]);\n    });\n    const comparisonWS = xlsx__WEBPACK_IMPORTED_MODULE_1__.utils.aoa_to_sheet(comparisonData);\n    comparisonWS['!cols'] = [\n        {\n            wch: 30\n        },\n        {\n            wch: 15\n        },\n        {\n            wch: 15\n        },\n        {\n            wch: 18\n        },\n        {\n            wch: 15\n        }\n    ];\n    xlsx__WEBPACK_IMPORTED_MODULE_1__.utils.book_append_sheet(workbook, comparisonWS, '📈 Oberflächen-Vergleich');\n    // === 5. ALLE BEFUNDE KONSOLIDIERT ===\n    const befundeData = [\n        [\n            'ALLE BEFUNDE (KONSOLIDIERT)'\n        ],\n        [\n            ''\n        ],\n        [\n            'Oberfläche',\n            'Typ',\n            'Befund-ID',\n            'Kategorie',\n            'Schweregrad',\n            'Titel',\n            'Beschreibung'\n        ]\n    ];\n    data.analyses.forEach((analysis)=>{\n        analysis.analysisData.befunde.forEach((befund)=>{\n            befundeData.push([\n                analysis.surfaceName,\n                analysis.surfaceType,\n                befund.befundId,\n                befund.kategorie,\n                befund.schweregrad,\n                befund.titel,\n                befund.beschreibung\n            ]);\n        });\n    });\n    const befundeWS = xlsx__WEBPACK_IMPORTED_MODULE_1__.utils.aoa_to_sheet(befundeData);\n    befundeWS['!cols'] = [\n        {\n            wch: 25\n        },\n        {\n            wch: 12\n        },\n        {\n            wch: 25\n        },\n        {\n            wch: 15\n        },\n        {\n            wch: 15\n        },\n        {\n            wch: 30\n        },\n        {\n            wch: 80\n        } // Beschreibung\n    ];\n    xlsx__WEBPACK_IMPORTED_MODULE_1__.utils.book_append_sheet(workbook, befundeWS, '📋 Alle Befunde');\n    // === 5. EINZELNE ANALYSEN (als separate Sheets) ===\n    data.analyses.forEach((analysis, index)=>{\n        const analysisData = [\n            [\n                \"ANALYSE: \".concat(analysis.surfaceName)\n            ],\n            [\n                ''\n            ],\n            [\n                'META-INFORMATIONEN'\n            ],\n            [\n                'Oberfläche',\n                analysis.surfaceName\n            ],\n            [\n                'Typ',\n                analysis.surfaceType\n            ],\n            [\n                'Kategorie',\n                analysis.surfaceCategory\n            ],\n            [\n                'Erstellt am',\n                analysis.createdAt.toLocaleDateString('de-DE')\n            ],\n            [\n                'Tags',\n                analysis.tags.join(', ')\n            ],\n            [\n                ''\n            ],\n            [\n                'ANALYSE-DETAILS'\n            ],\n            [\n                'Titel',\n                analysis.analysisData.titel\n            ],\n            [\n                'Prompt-Variante',\n                analysis.analysisData.promptVariante\n            ],\n            [\n                'LLM-Modell',\n                analysis.analysisData.llmModell\n            ],\n            [\n                'Verarbeitungszeit (ms)',\n                analysis.analysisData.verarbeitungszeit\n            ],\n            [\n                ''\n            ],\n            [\n                'BEFUNDE'\n            ],\n            [\n                'Befund-ID',\n                'Kategorie',\n                'Schweregrad',\n                'Titel',\n                'Beschreibung'\n            ]\n        ];\n        analysis.analysisData.befunde.forEach((befund)=>{\n            analysisData.push([\n                befund.befundId,\n                befund.kategorie,\n                befund.schweregrad,\n                befund.titel,\n                befund.beschreibung\n            ]);\n        });\n        const analysisWS = xlsx__WEBPACK_IMPORTED_MODULE_1__.utils.aoa_to_sheet(analysisData);\n        analysisWS['!cols'] = [\n            {\n                wch: 25\n            },\n            {\n                wch: 15\n            },\n            {\n                wch: 15\n            },\n            {\n                wch: 30\n            },\n            {\n                wch: 80\n            } // Beschreibung\n        ];\n        // Sheet-Name kürzen falls nötig (Excel-Limit: 31 Zeichen)\n        const sheetName = analysis.surfaceName.length > 25 ? \"\".concat(analysis.surfaceName.substring(0, 22), \"...\") : analysis.surfaceName;\n        xlsx__WEBPACK_IMPORTED_MODULE_1__.utils.book_append_sheet(workbook, analysisWS, \"\".concat(index + 1, \". \").concat(sheetName));\n    });\n    console.log(\"✅ Aggregated Excel mit \".concat(workbook.SheetNames.length, \" Arbeitsbl\\xe4ttern erstellt\"));\n    return workbook;\n}\n// 🚀 Main Export Function\nfunction exportAggregatedExcel(projectId) {\n    try {\n        console.log(\"\\uD83D\\uDE80 Starte Aggregated Excel Export f\\xfcr Projekt \".concat(projectId, \"...\"));\n        // Projekt-Daten analysieren\n        const aggregatedData = CrossSurfaceAnalyzer.analyzeProject(projectId);\n        // Excel-Workbook erstellen\n        const workbook = createAggregatedExcelWorkbook(aggregatedData);\n        // Dateiname generieren\n        const safeProjectName = aggregatedData.projectInfo.projectName.replace(/[^a-zA-Z0-9]/g, '_');\n        const filename = \"Projekt_\".concat(safeProjectName, \"_Aggregated_\").concat(aggregatedData.projectInfo.exportId, \".xlsx\");\n        // Download starten\n        const excelBuffer = xlsx__WEBPACK_IMPORTED_MODULE_1__.write(workbook, {\n            bookType: 'xlsx',\n            type: 'array',\n            compression: true\n        });\n        const blob = new Blob([\n            excelBuffer\n        ], {\n            type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\n        });\n        const url = URL.createObjectURL(blob);\n        const link = document.createElement('a');\n        link.href = url;\n        link.download = filename;\n        link.style.display = 'none';\n        document.body.appendChild(link);\n        link.click();\n        setTimeout(()=>{\n            document.body.removeChild(link);\n            URL.revokeObjectURL(url);\n        }, 100);\n        // Erfolgs-Feedback\n        alert(\"\\uD83C\\uDFAF Aggregated Excel Export erfolgreich!\\n\\n\" + \"Projekt: \".concat(aggregatedData.projectInfo.projectName, \"\\n\") + \"Datei: \".concat(filename, \"\\n\\n\") + \"Inhalt:\\n\" + \"• \".concat(aggregatedData.projectInfo.totalAnalyses, \" Analysen\\n\") + \"• \".concat(aggregatedData.crossSurfaceAnalysis.totalBefunde, \" Befunde\\n\") + \"• \".concat(workbook.SheetNames.length, \" Arbeitsbl\\xe4tter\\n\") + \"• Cross-Surface Analyse\\n\" + \"• Trend-Analyse\\n\\n\" + \"Die Datei wurde heruntergeladen.\");\n        console.log(\"✅ Aggregated Excel Export abgeschlossen: \".concat(filename));\n    } catch (error) {\n        console.error('❌ Aggregated Excel Export Fehler:', error);\n        const errorMessage = error instanceof Error ? error.message : 'Unbekannter Fehler';\n        alert(\"❌ Aggregated Excel Export fehlgeschlagen!\\n\\nFehler: \".concat(errorMessage));\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYWdncmVnYXRlZEV4cG9ydC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLHdFQUF3RTtBQUN4RSw2RUFBNkU7QUFFaEQ7QUFDc0Q7QUF1RG5GLG1DQUFtQztBQUM1QixNQUFNRTtJQUVYLE9BQU9DLGVBQWVDLFNBQWlCLEVBQXdCO1lBaUJqREMsU0FDRkE7UUFqQlYsTUFBTUMsVUFBVUwsMkRBQWNBLENBQUNNLFVBQVUsQ0FBQ0g7UUFDMUMsTUFBTUksV0FBV1AsMkRBQWNBLENBQUNRLG9CQUFvQixDQUFDTDtRQUVyRCxJQUFJLENBQUNFLFdBQVdFLFNBQVNFLE1BQU0sS0FBSyxHQUFHO1lBQ3JDLE1BQU0sSUFBSUMsTUFBTSxXQUFxQixPQUFWUCxXQUFVO1FBQ3ZDO1FBRUFRLFFBQVFDLEdBQUcsQ0FBQyxvQ0FBc0RMLE9BQTVCRixRQUFRUSxXQUFXLEVBQUMsVUFBd0IsT0FBaEJOLFNBQVNFLE1BQU0sRUFBQztRQUVsRixxQ0FBcUM7UUFDckMsTUFBTUssZ0JBQWdCLElBQUksQ0FBQ0MsMkJBQTJCLENBQUNSO1FBQ3ZELE1BQU1TLGVBQWUsSUFBSSxDQUFDQyxxQkFBcUIsQ0FBQ1Y7UUFFaEQsd0JBQXdCO1FBQ3hCLE1BQU1ILFFBQVFHLFNBQVNXLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsU0FBUyxFQUFFQyxJQUFJLENBQUMsQ0FBQ0YsR0FBR0csSUFBTUgsRUFBRUksT0FBTyxLQUFLRCxFQUFFQyxPQUFPO1FBQ25GLE1BQU1DLFlBQVk7WUFDaEJDLFVBQVVyQixFQUFBQSxVQUFBQSxLQUFLLENBQUMsRUFBRSxjQUFSQSw4QkFBQUEsUUFBVXNCLGtCQUFrQixDQUFDLGFBQVk7WUFDbkRDLFFBQVF2QixFQUFBQSxXQUFBQSxLQUFLLENBQUNBLE1BQU1LLE1BQU0sR0FBRyxFQUFFLGNBQXZCTCwrQkFBQUEsU0FBeUJzQixrQkFBa0IsQ0FBQyxhQUFZO1FBQ2xFO1FBRUEsTUFBTUUsV0FBVyxP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WSxFQUFFO1lBQ25DRyxNQUFNO1FBQ1I7UUFFQSxNQUFNSSxNQUFNQyxJQUFJQyxlQUFlLENBQUNKO1FBQ2hDLE1BQU1LLE9BQU9DLFNBQVNDLGFBQWEsQ0FBQztRQUNwQ0YsS0FBS0csSUFBSSxHQUFHTjtRQUNaRyxLQUFLSSxRQUFRLEdBQUdmO1FBQ2hCVyxLQUFLSyxLQUFLLENBQUNDLE9BQU8sR0FBRztRQUVyQkwsU0FBU00sSUFBSSxDQUFDQyxXQUFXLENBQUNSO1FBQzFCQSxLQUFLUyxLQUFLO1FBRVZDLFdBQVc7WUFDVFQsU0FBU00sSUFBSSxDQUFDSSxXQUFXLENBQUNYO1lBQzFCRixJQUFJYyxlQUFlLENBQUNmO1FBQ3RCLEdBQUc7UUFFSCxtQkFBbUI7UUFDbkJnQixNQUFNLDBEQUNBLFlBQW1ELE9BQXZDM0IsZUFBZXhILFdBQVcsQ0FBQ3ZCLFdBQVcsRUFBQyxRQUNuRCxVQUFtQixPQUFUa0osVUFBUyxVQUNsQixjQUNELEtBQThDLE9BQXpDSCxlQUFleEgsV0FBVyxDQUFDRSxhQUFhLEVBQUMsaUJBQzlDLEtBQXNELE9BQWpEc0gsZUFBZXBILG9CQUFvQixDQUFDb0IsWUFBWSxFQUFDLGdCQUN0RCxLQUFnQyxPQUEzQnlELFNBQVNxQyxVQUFVLENBQUNqSixNQUFNLEVBQUMsMEJBQy9CLDhCQUNBLHdCQUNBO1FBRVBFLFFBQVFDLEdBQUcsQ0FBQyw0Q0FBcUQsT0FBVG1KO0lBRTFELEVBQUUsT0FBT3lCLE9BQU87UUFDZDdLLFFBQVE2SyxLQUFLLENBQUMscUNBQXFDQTtRQUNuRCxNQUFNQyxlQUFlRCxpQkFBaUI5SyxRQUFROEssTUFBTUUsT0FBTyxHQUFHO1FBQzlESCxNQUFNLHdEQUFxRSxPQUFiRTtJQUNoRTtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEthcmltXFxXZWJzdG9ybVByb2plY3RzXFxVWFNjb3BlXFxzcmNcXGxpYlxcYWdncmVnYXRlZEV4cG9ydC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyDwn46vIEFnZ3JlZ2F0ZWQgRXhjZWwgRXhwb3J0IC0gTXVsdGktU3VyZmFjZSBBbmFseXNpcyBBZ2dyZWdhdG9yIChNU0FBKVxyXG4vLyBFeHBvcnRpZXJ0IG1laHJlcmUgQW5hbHlzZW4gZWluZXMgUHJvamVrdHMgaW4gZWluZW0gdW1mYXNzZW5kZW4gRXhjZWwtRmlsZVxyXG5cclxuaW1wb3J0ICogYXMgWExTWCBmcm9tICd4bHN4JztcclxuaW1wb3J0IHsgUHJvamVjdE1hbmFnZXIsIEFuYWx5c2lzUHJvamVjdCwgU3RvcmVkQW5hbHlzaXMgfSBmcm9tICcuL3Byb2plY3RNYW5hZ2VyJztcclxuaW1wb3J0IHsgRXhjZWxFeHBvcnREYXRhIH0gZnJvbSAnLi9leGNlbEV4cG9ydCc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEFnZ3JlZ2F0ZWRFeHBvcnREYXRhIHtcclxuICAvLyBQcm9qZWt0LU1ldGEtSW5mb3JtYXRpb25lblxyXG4gIHByb2plY3RJbmZvOiB7XHJcbiAgICBwcm9qZWN0SWQ6IHN0cmluZztcclxuICAgIHByb2plY3ROYW1lOiBzdHJpbmc7XHJcbiAgICBwcm9qZWN0RGVzY3JpcHRpb246IHN0cmluZztcclxuICAgIHRvdGFsQW5hbHlzZXM6IG51bWJlcjtcclxuICAgIGRhdGVSYW5nZToge1xyXG4gICAgICBlYXJsaWVzdDogc3RyaW5nO1xyXG4gICAgICBsYXRlc3Q6IHN0cmluZztcclxuICAgIH07XHJcbiAgICBleHBvcnREYXRlOiBzdHJpbmc7XHJcbiAgICBleHBvcnRJZDogc3RyaW5nO1xyXG4gIH07XHJcbiAgXHJcbiAgLy8gQWxsZSBBbmFseXNlbiBkZXMgUHJvamVrdHNcclxuICBhbmFseXNlczogU3RvcmVkQW5hbHlzaXNbXTtcclxuICBcclxuICAvLyBDcm9zcy1TdXJmYWNlIEluc2lnaHRzXHJcbiAgY3Jvc3NTdXJmYWNlQW5hbHlzaXM6IHtcclxuICAgIHRvdGFsQmVmdW5kZTogbnVtYmVyO1xyXG4gICAgY29tbW9uUHJvYmxlbXM6IEFycmF5PHtcclxuICAgICAgcHJvYmxlbTogc3RyaW5nO1xyXG4gICAgICBvY2N1cnJlbmNlczogbnVtYmVyO1xyXG4gICAgICBzdXJmYWNlczogc3RyaW5nW107XHJcbiAgICAgIHNldmVyaXR5OiBzdHJpbmc7XHJcbiAgICB9PjtcclxuICAgIHNldmVyaXR5RGlzdHJpYnV0aW9uOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+O1xyXG4gICAgc3VyZmFjZUNvbXBhcmlzb246IEFycmF5PHtcclxuICAgICAgc3VyZmFjZU5hbWU6IHN0cmluZztcclxuICAgICAgc3VyZmFjZVR5cGU6IHN0cmluZztcclxuICAgICAgYmVmdW5kZUNvdW50OiBudW1iZXI7XHJcbiAgICAgIGNyaXRpY2FsSXNzdWVzOiBudW1iZXI7XHJcbiAgICAgIGF2ZXJhZ2VTZXZlcml0eTogc3RyaW5nO1xyXG4gICAgfT47XHJcbiAgICB0cmVuZHM6IHtcclxuICAgICAgaW1wcm92aW5nQXJlYXM6IHN0cmluZ1tdO1xyXG4gICAgICB3b3JzZW5pbmdBcmVhczogc3RyaW5nW107XHJcbiAgICB9O1xyXG4gIH07XHJcbiAgXHJcbiAgLy8gUHJvamVrdC1TdGF0aXN0aWtlblxyXG4gIHByb2plY3RTdGF0czoge1xyXG4gICAgcHJvbXB0VmFyaWFudHNVc2VkOiBzdHJpbmdbXTtcclxuICAgIGxsbU1vZGVsc1VzZWQ6IHN0cmluZ1tdO1xyXG4gICAgc3VyZmFjZVR5cGVzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+O1xyXG4gICAgc3VyZmFjZUNhdGVnb3JpZXM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj47XHJcbiAgICB0b3RhbFByb2Nlc3NpbmdUaW1lOiBudW1iZXI7XHJcbiAgICBhbmFseXNpc0VmZmljaWVuY3k6IG51bWJlcjsgLy8gQmVmdW5kZSBwcm8gTWludXRlXHJcbiAgfTtcclxufVxyXG5cclxuLy8g8J+noCBDcm9zcy1TdXJmYWNlIEFuYWx5c2lzIEVuZ2luZVxyXG5leHBvcnQgY2xhc3MgQ3Jvc3NTdXJmYWNlQW5hbHl6ZXIge1xyXG4gIFxyXG4gIHN0YXRpYyBhbmFseXplUHJvamVjdChwcm9qZWN0SWQ6IHN0cmluZyk6IEFnZ3JlZ2F0ZWRFeHBvcnREYXRhIHtcclxuICAgIGNvbnN0IHByb2plY3QgPSBQcm9qZWN0TWFuYWdlci5nZXRQcm9qZWN0KHByb2plY3RJZCk7XHJcbiAgICBjb25zdCBhbmFseXNlcyA9IFByb2plY3RNYW5hZ2VyLmdldEFuYWx5c2VzQnlQcm9qZWN0KHByb2plY3RJZCk7XHJcbiAgICBcclxuICAgIGlmICghcHJvamVjdCB8fCBhbmFseXNlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9qZWt0ICR7cHJvamVjdElkfSBuaWNodCBnZWZ1bmRlbiBvZGVyIGxlZXJgKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coYPCflI0gQW5hbHlzaWVyZSBQcm9qZWt0IFwiJHtwcm9qZWN0LnByb2plY3ROYW1lfVwiIG1pdCAke2FuYWx5c2VzLmxlbmd0aH0gQW5hbHlzZW4uLi5gKTtcclxuICAgIFxyXG4gICAgLy8gQ3Jvc3MtU3VyZmFjZSBBbmFseXNpcyBkdXJjaGbDvGhyZW5cclxuICAgIGNvbnN0IGNyb3NzQW5hbHlzaXMgPSB0aGlzLnBlcmZvcm1Dcm9zc1N1cmZhY2VBbmFseXNpcyhhbmFseXNlcyk7XHJcbiAgICBjb25zdCBwcm9qZWN0U3RhdHMgPSB0aGlzLmNhbGN1bGF0ZVByb2plY3RTdGF0cyhhbmFseXNlcyk7XHJcbiAgICBcclxuICAgIC8vIERhdHVtLVJhbmdlIGVybWl0dGVsblxyXG4gICAgY29uc3QgZGF0ZXMgPSBhbmFseXNlcy5tYXAoYSA9PiBhLmNyZWF0ZWRBdCkuc29ydCgoYSwgYikgPT4gYS5nZXRUaW1lKCkgLSBiLmdldFRpbWUoKSk7XHJcbiAgICBjb25zdCBkYXRlUmFuZ2UgPSB7XHJcbiAgICAgIGVhcmxpZXN0OiBkYXRlc1swXT8udG9Mb2NhbGVEYXRlU3RyaW5nKCdkZS1ERScpIHx8ICdVbmJla2FubnQnLFxyXG4gICAgICBsYXRlc3Q6IGRhdGVzW2RhdGVzLmxlbmd0aCAtIDFdPy50b0xvY2FsZURhdGVTdHJpbmcoJ2RlLURFJykgfHwgJ1VuYmVrYW5udCdcclxuICAgIH07XHJcbiAgICBcclxuICAgIGNvbnN0IGV4cG9ydElkID0gYEFHR18ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDgpfWAudG9VcHBlckNhc2UoKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcHJvamVjdEluZm86IHtcclxuICAgICAgICBwcm9qZWN0SWQ6IHByb2plY3QucHJvamVjdElkLFxyXG4gICAgICAgIHByb2plY3ROYW1lOiBwcm9qZWN0LnByb2plY3ROYW1lLFxyXG4gICAgICAgIHByb2plY3REZXNjcmlwdGlvbjogcHJvamVjdC5wcm9qZWN0RGVzY3JpcHRpb24sXHJcbiAgICAgICAgdG90YWxBbmFseXNlczogYW5hbHlzZXMubGVuZ3RoLFxyXG4gICAgICAgIGRhdGVSYW5nZSxcclxuICAgICAgICBleHBvcnREYXRlOiBuZXcgRGF0ZSgpLnRvTG9jYWxlRGF0ZVN0cmluZygnZGUtREUnKSxcclxuICAgICAgICBleHBvcnRJZFxyXG4gICAgICB9LFxyXG4gICAgICBhbmFseXNlcyxcclxuICAgICAgY3Jvc3NTdXJmYWNlQW5hbHlzaXM6IGNyb3NzQW5hbHlzaXMsXHJcbiAgICAgIHByb2plY3RTdGF0c1xyXG4gICAgfTtcclxuICB9XHJcbiAgXHJcbiAgcHJpdmF0ZSBzdGF0aWMgcGVyZm9ybUNyb3NzU3VyZmFjZUFuYWx5c2lzKGFuYWx5c2VzOiBTdG9yZWRBbmFseXNpc1tdKSB7XHJcbiAgICBjb25zdCBhbGxCZWZ1bmRlID0gYW5hbHlzZXMuZmxhdE1hcChhbmFseXNpcyA9PiBcclxuICAgICAgYW5hbHlzaXMuYW5hbHlzaXNEYXRhLmJlZnVuZGUubWFwKGJlZnVuZCA9PiAoe1xyXG4gICAgICAgIC4uLmJlZnVuZCxcclxuICAgICAgICBzdXJmYWNlTmFtZTogYW5hbHlzaXMuc3VyZmFjZU5hbWUsXHJcbiAgICAgICAgc3VyZmFjZVR5cGU6IGFuYWx5c2lzLnN1cmZhY2VUeXBlLFxyXG4gICAgICAgIGFuYWx5c2lzSWQ6IGFuYWx5c2lzLmFuYWx5c2lzSWRcclxuICAgICAgfSkpXHJcbiAgICApO1xyXG4gICAgXHJcbiAgICAvLyBIw6R1ZmlnZSBQcm9ibGVtZSBlcmtlbm5lbiAoYmFzaWVyZW5kIGF1ZiDDpGhubGljaGVuIFRpdGVsbi9CZXNjaHJlaWJ1bmdlbilcclxuICAgIGNvbnN0IGNvbW1vblByb2JsZW1zID0gdGhpcy5kZXRlY3RDb21tb25Qcm9ibGVtcyhhbGxCZWZ1bmRlKTtcclxuICAgIFxyXG4gICAgLy8gU2Nod2VyZWdyYWQtVmVydGVpbHVuZ1xyXG4gICAgY29uc3Qgc2V2ZXJpdHlEaXN0cmlidXRpb24gPSBhbGxCZWZ1bmRlLnJlZHVjZSgoYWNjLCBiZWZ1bmQpID0+IHtcclxuICAgICAgYWNjW2JlZnVuZC5zY2h3ZXJlZ3JhZF0gPSAoYWNjW2JlZnVuZC5zY2h3ZXJlZ3JhZF0gfHwgMCkgKyAxO1xyXG4gICAgICByZXR1cm4gYWNjO1xyXG4gICAgfSwge30gYXMgUmVjb3JkPHN0cmluZywgbnVtYmVyPik7XHJcbiAgICBcclxuICAgIC8vIE9iZXJmbMOkY2hlbi1WZXJnbGVpY2hcclxuICAgIGNvbnN0IHN1cmZhY2VDb21wYXJpc29uID0gdGhpcy5jb21wYXJlU3VyZmFjZXMoYW5hbHlzZXMpO1xyXG4gICAgXHJcbiAgICAvLyBUcmVuZHMgKHZlcmVpbmZhY2h0IC0gYmFzaWVyZW5kIGF1ZiBDaHJvbm9sb2dpZSlcclxuICAgIGNvbnN0IHRyZW5kcyA9IHRoaXMuYW5hbHl6ZVRyZW5kcyhhbmFseXNlcyk7XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRvdGFsQmVmdW5kZTogYWxsQmVmdW5kZS5sZW5ndGgsXHJcbiAgICAgIGNvbW1vblByb2JsZW1zLFxyXG4gICAgICBzZXZlcml0eURpc3RyaWJ1dGlvbixcclxuICAgICAgc3VyZmFjZUNvbXBhcmlzb24sXHJcbiAgICAgIHRyZW5kc1xyXG4gICAgfTtcclxuICB9XHJcbiAgXHJcbiAgcHJpdmF0ZSBzdGF0aWMgZGV0ZWN0Q29tbW9uUHJvYmxlbXMoYmVmdW5kZTogYW55W10pIHtcclxuICAgIC8vIEdydXBwaWVyZSDDpGhubGljaGUgUHJvYmxlbWUgYmFzaWVyZW5kIGF1ZiBLZXl3b3JkcyBpbiBUaXRlbC9CZXNjaHJlaWJ1bmdcclxuICAgIGNvbnN0IHByb2JsZW1Hcm91cHM6IFJlY29yZDxzdHJpbmcsIGFueVtdPiA9IHt9O1xyXG4gICAgXHJcbiAgICBjb25zdCBrZXl3b3JkcyA9IFtcclxuICAgICAgJ25hdmlnYXRpb24nLCAnYnV0dG9uJywgJ3RleHQnLCAnY29sb3InLCAnY29udHJhc3QnLCAnbGF5b3V0JywgJ21vYmlsZScsIFxyXG4gICAgICAncmVzcG9uc2l2ZScsICdhY2Nlc3NpYmlsaXR5JywgJ2xvYWRpbmcnLCAnZXJyb3InLCAnZm9ybScsICd2YWxpZGF0aW9uJyxcclxuICAgICAgJ3VzYWJpbGl0eScsICd1c2VyJywgJ2ludGVyZmFjZScsICdkZXNpZ24nLCAnZnVuY3Rpb25hbGl0eSdcclxuICAgIF07XHJcbiAgICBcclxuICAgIGJlZnVuZGUuZm9yRWFjaChiZWZ1bmQgPT4ge1xyXG4gICAgICBjb25zdCB0ZXh0ID0gYCR7YmVmdW5kLnRpdGVsfSAke2JlZnVuZC5iZXNjaHJlaWJ1bmd9YC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICBcclxuICAgICAgLy8gRmluZGUgcmVsZXZhbnRlIEtleXdvcmRzXHJcbiAgICAgIGNvbnN0IGZvdW5kS2V5d29yZHMgPSBrZXl3b3Jkcy5maWx0ZXIoa2V5d29yZCA9PiB0ZXh0LmluY2x1ZGVzKGtleXdvcmQpKTtcclxuICAgICAgXHJcbiAgICAgIGlmIChmb3VuZEtleXdvcmRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zdCBwcmltYXJ5S2V5d29yZCA9IGZvdW5kS2V5d29yZHNbMF07IC8vIE5laG1lIGRhcyBlcnN0ZSBnZWZ1bmRlbmUgS2V5d29yZFxyXG4gICAgICAgIGlmICghcHJvYmxlbUdyb3Vwc1twcmltYXJ5S2V5d29yZF0pIHtcclxuICAgICAgICAgIHByb2JsZW1Hcm91cHNbcHJpbWFyeUtleXdvcmRdID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb2JsZW1Hcm91cHNbcHJpbWFyeUtleXdvcmRdLnB1c2goYmVmdW5kKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIEtvbnZlcnRpZXJlIHp1IGNvbW1vbiBwcm9ibGVtcyBGb3JtYXRcclxuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhwcm9ibGVtR3JvdXBzKVxyXG4gICAgICAuZmlsdGVyKChbLCBncm91cF0pID0+IGdyb3VwLmxlbmd0aCA+IDEpIC8vIE51ciBQcm9ibGVtZSBkaWUgbWVocmZhY2ggYXVmdHJldGVuXHJcbiAgICAgIC5tYXAoKFtrZXl3b3JkLCBncm91cF0pID0+ICh7XHJcbiAgICAgICAgcHJvYmxlbTogYCR7a2V5d29yZC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleXdvcmQuc2xpY2UoMSl9LWJlem9nZW5lIFByb2JsZW1lYCxcclxuICAgICAgICBvY2N1cnJlbmNlczogZ3JvdXAubGVuZ3RoLFxyXG4gICAgICAgIHN1cmZhY2VzOiBbLi4ubmV3IFNldChncm91cC5tYXAoYiA9PiBiLnN1cmZhY2VOYW1lKSldLFxyXG4gICAgICAgIHNldmVyaXR5OiB0aGlzLmdldE1vc3RDb21tb25TZXZlcml0eShncm91cClcclxuICAgICAgfSkpXHJcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBiLm9jY3VycmVuY2VzIC0gYS5vY2N1cnJlbmNlcylcclxuICAgICAgLnNsaWNlKDAsIDEwKTsgLy8gVG9wIDEwIGjDpHVmaWdzdGUgUHJvYmxlbWVcclxuICB9XHJcbiAgXHJcbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0TW9zdENvbW1vblNldmVyaXR5KGJlZnVuZGU6IGFueVtdKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IHNldmVyaXR5Q291bnRzID0gYmVmdW5kZS5yZWR1Y2UoKGFjYywgYikgPT4ge1xyXG4gICAgICBhY2NbYi5zY2h3ZXJlZ3JhZF0gPSAoYWNjW2Iuc2Nod2VyZWdyYWRdIHx8IDApICsgMTtcclxuICAgICAgcmV0dXJuIGFjYztcclxuICAgIH0sIHt9IGFzIFJlY29yZDxzdHJpbmcsIG51bWJlcj4pO1xyXG4gICAgXHJcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoc2V2ZXJpdHlDb3VudHMpXHJcbiAgICAgIC5zb3J0KChbLGFdLCBbLGJdKSA9PiAoYiBhcyBudW1iZXIpIC0gKGEgYXMgbnVtYmVyKSlbMF0/LlswXSB8fCAndW5rbm93bic7XHJcbiAgfVxyXG4gIFxyXG4gIHByaXZhdGUgc3RhdGljIGNvbXBhcmVTdXJmYWNlcyhhbmFseXNlczogU3RvcmVkQW5hbHlzaXNbXSkge1xyXG4gICAgcmV0dXJuIGFuYWx5c2VzLm1hcChhbmFseXNpcyA9PiB7XHJcbiAgICAgIGNvbnN0IGJlZnVuZGUgPSBhbmFseXNpcy5hbmFseXNpc0RhdGEuYmVmdW5kZTtcclxuICAgICAgY29uc3QgY3JpdGljYWxJc3N1ZXMgPSBiZWZ1bmRlLmZpbHRlcihiID0+IFxyXG4gICAgICAgIFsnY3JpdGljYWwnLCAnY2F0YXN0cm9waGljJywgJ3NlcmlvdXMnXS5pbmNsdWRlcyhiLnNjaHdlcmVncmFkKVxyXG4gICAgICApLmxlbmd0aDtcclxuICAgICAgXHJcbiAgICAgIC8vIER1cmNoc2Nobml0dGxpY2hlciBTY2h3ZXJlZ3JhZCAodmVyZWluZmFjaHQpXHJcbiAgICAgIGNvbnN0IHNldmVyaXR5U2NvcmVzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0geyBcclxuICAgICAgICAnY2F0YXN0cm9waGljJzogNSwgJ2NyaXRpY2FsJzogNCwgJ3NlcmlvdXMnOiAzLCAnbWlub3InOiAyLCAncG9zaXRpdmUnOiAxLCAnTmljaHQgYmV3ZXJ0ZXQnOiAwIFxyXG4gICAgICB9O1xyXG4gICAgICBjb25zdCBhdmdTY29yZSA9IGJlZnVuZGUubGVuZ3RoID4gMCBcclxuICAgICAgICA/IGJlZnVuZGUucmVkdWNlKChzdW0sIGIpID0+IHN1bSArIChzZXZlcml0eVNjb3Jlc1tiLnNjaHdlcmVncmFkXSB8fCAwKSwgMCkgLyBiZWZ1bmRlLmxlbmd0aFxyXG4gICAgICAgIDogMDtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGF2Z1NldmVyaXR5ID0gYXZnU2NvcmUgPj0gNCA/ICdIb2NoJyA6IGF2Z1Njb3JlID49IDIuNSA/ICdNaXR0ZWwnIDogJ05pZWRyaWcnO1xyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdXJmYWNlTmFtZTogYW5hbHlzaXMuc3VyZmFjZU5hbWUsXHJcbiAgICAgICAgc3VyZmFjZVR5cGU6IGFuYWx5c2lzLnN1cmZhY2VUeXBlLFxyXG4gICAgICAgIGJlZnVuZGVDb3VudDogYmVmdW5kZS5sZW5ndGgsXHJcbiAgICAgICAgY3JpdGljYWxJc3N1ZXMsXHJcbiAgICAgICAgYXZlcmFnZVNldmVyaXR5OiBhdmdTZXZlcml0eVxyXG4gICAgICB9O1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIFxyXG4gIHByaXZhdGUgc3RhdGljIGFuYWx5emVUcmVuZHMoYW5hbHlzZXM6IFN0b3JlZEFuYWx5c2lzW10pIHtcclxuICAgIC8vIFNvcnRpZXJlIEFuYWx5c2VuIGNocm9ub2xvZ2lzY2hcclxuICAgIGNvbnN0IHNvcnRlZEFuYWx5c2VzID0gWy4uLmFuYWx5c2VzXS5zb3J0KChhLCBiKSA9PiBhLmNyZWF0ZWRBdC5nZXRUaW1lKCkgLSBiLmNyZWF0ZWRBdC5nZXRUaW1lKCkpO1xyXG4gICAgXHJcbiAgICAvLyBWZXJlaW5mYWNodGUgVHJlbmQtQW5hbHlzZSBiYXNpZXJlbmQgYXVmIEFuemFobCBrcml0aXNjaGVyIFByb2JsZW1lIMO8YmVyIFplaXRcclxuICAgIGNvbnN0IGltcHJvdmluZ0FyZWFzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgY29uc3Qgd29yc2VuaW5nQXJlYXM6IHN0cmluZ1tdID0gW107XHJcbiAgICBcclxuICAgIGlmIChzb3J0ZWRBbmFseXNlcy5sZW5ndGggPj0gMikge1xyXG4gICAgICBjb25zdCBlYXJseSA9IHNvcnRlZEFuYWx5c2VzLnNsaWNlKDAsIE1hdGguY2VpbChzb3J0ZWRBbmFseXNlcy5sZW5ndGggLyAyKSk7XHJcbiAgICAgIGNvbnN0IHJlY2VudCA9IHNvcnRlZEFuYWx5c2VzLnNsaWNlKE1hdGguZmxvb3Ioc29ydGVkQW5hbHlzZXMubGVuZ3RoIC8gMikpO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgZWFybHlDcml0aWNhbCA9IGVhcmx5LnJlZHVjZSgoc3VtLCBhKSA9PiBcclxuICAgICAgICBzdW0gKyBhLmFuYWx5c2lzRGF0YS5iZWZ1bmRlLmZpbHRlcihiID0+IFsnY3JpdGljYWwnLCAnY2F0YXN0cm9waGljJ10uaW5jbHVkZXMoYi5zY2h3ZXJlZ3JhZCkpLmxlbmd0aCwgMFxyXG4gICAgICApIC8gZWFybHkubGVuZ3RoO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgcmVjZW50Q3JpdGljYWwgPSByZWNlbnQucmVkdWNlKChzdW0sIGEpID0+IFxyXG4gICAgICAgIHN1bSArIGEuYW5hbHlzaXNEYXRhLmJlZnVuZGUuZmlsdGVyKGIgPT4gWydjcml0aWNhbCcsICdjYXRhc3Ryb3BoaWMnXS5pbmNsdWRlcyhiLnNjaHdlcmVncmFkKSkubGVuZ3RoLCAwXHJcbiAgICAgICkgLyByZWNlbnQubGVuZ3RoO1xyXG4gICAgICBcclxuICAgICAgaWYgKHJlY2VudENyaXRpY2FsIDwgZWFybHlDcml0aWNhbCkge1xyXG4gICAgICAgIGltcHJvdmluZ0FyZWFzLnB1c2goJ0tyaXRpc2NoZSBQcm9ibGVtZSByZWR1emllcnQnKTtcclxuICAgICAgfSBlbHNlIGlmIChyZWNlbnRDcml0aWNhbCA+IGVhcmx5Q3JpdGljYWwpIHtcclxuICAgICAgICB3b3JzZW5pbmdBcmVhcy5wdXNoKCdLcml0aXNjaGUgUHJvYmxlbWUgZ2VzdGllZ2VuJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHsgaW1wcm92aW5nQXJlYXMsIHdvcnNlbmluZ0FyZWFzIH07XHJcbiAgfVxyXG4gIFxyXG4gIHByaXZhdGUgc3RhdGljIGNhbGN1bGF0ZVByb2plY3RTdGF0cyhhbmFseXNlczogU3RvcmVkQW5hbHlzaXNbXSkge1xyXG4gICAgY29uc3QgcHJvbXB0VmFyaWFudHMgPSBbLi4ubmV3IFNldChhbmFseXNlcy5tYXAoYSA9PiBhLmFuYWx5c2lzRGF0YS5wcm9tcHRWYXJpYW50ZSkpXTtcclxuICAgIGNvbnN0IGxsbU1vZGVscyA9IFsuLi5uZXcgU2V0KGFuYWx5c2VzLm1hcChhID0+IGEuYW5hbHlzaXNEYXRhLmxsbU1vZGVsbCkpXTtcclxuICAgIFxyXG4gICAgY29uc3Qgc3VyZmFjZVR5cGVzID0gYW5hbHlzZXMucmVkdWNlKChhY2MsIGEpID0+IHtcclxuICAgICAgYWNjW2Euc3VyZmFjZVR5cGVdID0gKGFjY1thLnN1cmZhY2VUeXBlXSB8fCAwKSArIDE7XHJcbiAgICAgIHJldHVybiBhY2M7XHJcbiAgICB9LCB7fSBhcyBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+KTtcclxuICAgIFxyXG4gICAgY29uc3Qgc3VyZmFjZUNhdGVnb3JpZXMgPSBhbmFseXNlcy5yZWR1Y2UoKGFjYywgYSkgPT4ge1xyXG4gICAgICBhY2NbYS5zdXJmYWNlQ2F0ZWdvcnldID0gKGFjY1thLnN1cmZhY2VDYXRlZ29yeV0gfHwgMCkgKyAxO1xyXG4gICAgICByZXR1cm4gYWNjO1xyXG4gICAgfSwge30gYXMgUmVjb3JkPHN0cmluZywgbnVtYmVyPik7XHJcbiAgICBcclxuICAgIGNvbnN0IHRvdGFsUHJvY2Vzc2luZ1RpbWUgPSBhbmFseXNlcy5yZWR1Y2UoKHN1bSwgYSkgPT4gc3VtICsgYS5hbmFseXNpc0RhdGEudmVyYXJiZWl0dW5nc3plaXQsIDApO1xyXG4gICAgY29uc3QgdG90YWxCZWZ1bmRlID0gYW5hbHlzZXMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGEuYW5hbHlzaXNEYXRhLmJlZnVuZGUubGVuZ3RoLCAwKTtcclxuICAgIGNvbnN0IGFuYWx5c2lzRWZmaWNpZW5jeSA9IHRvdGFsUHJvY2Vzc2luZ1RpbWUgPiAwIFxyXG4gICAgICA/IE1hdGgucm91bmQoKHRvdGFsQmVmdW5kZSAvICh0b3RhbFByb2Nlc3NpbmdUaW1lIC8gNjAwMDApKSAqIDEwMCkgLyAxMDAgLy8gQmVmdW5kZSBwcm8gTWludXRlXHJcbiAgICAgIDogMDtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcHJvbXB0VmFyaWFudHNVc2VkOiBwcm9tcHRWYXJpYW50cyxcclxuICAgICAgbGxtTW9kZWxzVXNlZDogbGxtTW9kZWxzLFxyXG4gICAgICBzdXJmYWNlVHlwZXMsXHJcbiAgICAgIHN1cmZhY2VDYXRlZ29yaWVzLFxyXG4gICAgICB0b3RhbFByb2Nlc3NpbmdUaW1lLFxyXG4gICAgICBhbmFseXNpc0VmZmljaWVuY3lcclxuICAgIH07XHJcbiAgfVxyXG59XHJcblxyXG4vLyDwn5OKIEFnZ3JlZ2F0ZWQgRXhjZWwgV29ya2Jvb2sgQ3JlYXRvclxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQWdncmVnYXRlZEV4Y2VsV29ya2Jvb2soZGF0YTogQWdncmVnYXRlZEV4cG9ydERhdGEpOiBYTFNYLldvcmtCb29rIHtcclxuICBjb25zb2xlLmxvZyhg8J+TiiBFcnN0ZWxsZSBBZ2dyZWdhdGVkIEV4Y2VsIGbDvHIgUHJvamVrdCBcIiR7ZGF0YS5wcm9qZWN0SW5mby5wcm9qZWN0TmFtZX1cIi4uLmApO1xyXG4gIFxyXG4gIGNvbnN0IHdvcmtib29rID0gWExTWC51dGlscy5ib29rX25ldygpO1xyXG4gIFxyXG4gIC8vID09PSAxLiBQUk9KRUtULcOcQkVSU0lDSFQgPT09XHJcbiAgY29uc3Qgb3ZlcnZpZXdEYXRhID0gW1xyXG4gICAgWydQUk9KRUtULUFOQUxZU0Ugw5xCRVJTSUNIVCddLFxyXG4gICAgWycnXSxcclxuICAgIFsnUFJPSkVLVC1JTkZPUk1BVElPTkVOJ10sXHJcbiAgICBbJ1Byb2pla3RuYW1lJywgZGF0YS5wcm9qZWN0SW5mby5wcm9qZWN0TmFtZV0sXHJcbiAgICBbJ1Byb2pla3QgSUQnLCBkYXRhLnByb2plY3RJbmZvLnByb2plY3RJZF0sXHJcbiAgICBbJ0Jlc2NocmVpYnVuZycsIGRhdGEucHJvamVjdEluZm8ucHJvamVjdERlc2NyaXB0aW9uIHx8ICdLZWluZSBCZXNjaHJlaWJ1bmcnXSxcclxuICAgIFsnRXhwb3J0LURhdHVtJywgZGF0YS5wcm9qZWN0SW5mby5leHBvcnREYXRlXSxcclxuICAgIFsnRXhwb3J0LUlEJywgZGF0YS5wcm9qZWN0SW5mby5leHBvcnRJZF0sXHJcbiAgICBbJyddLFxyXG4gICAgWydBTkFMWVNFLVNUQVRJU1RJS0VOJ10sXHJcbiAgICBbJ0dlc2FtdGFuemFobCBBbmFseXNlbicsIGRhdGEucHJvamVjdEluZm8udG90YWxBbmFseXNlc10sXHJcbiAgICBbJ0dlc2FtdGFuemFobCBCZWZ1bmRlJywgZGF0YS5jcm9zc1N1cmZhY2VBbmFseXNpcy50b3RhbEJlZnVuZGVdLFxyXG4gICAgWydaZWl0cmF1bSAodm9uKScsIGRhdGEucHJvamVjdEluZm8uZGF0ZVJhbmdlLmVhcmxpZXN0XSxcclxuICAgIFsnWmVpdHJhdW0gKGJpcyknLCBkYXRhLnByb2plY3RJbmZvLmRhdGVSYW5nZS5sYXRlc3RdLFxyXG4gICAgWycnXSxcclxuICAgIFsnRUZGSVpJRU5aLU1FVFJJS0VOJ10sXHJcbiAgICBbJ0dlc2FtdGUgVmVyYXJiZWl0dW5nc3plaXQgKG1zKScsIGRhdGEucHJvamVjdFN0YXRzLnRvdGFsUHJvY2Vzc2luZ1RpbWVdLFxyXG4gICAgWydBbmFseXNlLUVmZml6aWVueiAoQmVmdW5kZS9NaW4pJywgZGF0YS5wcm9qZWN0U3RhdHMuYW5hbHlzaXNFZmZpY2llbmN5XSxcclxuICAgIFsnw5ggQmVmdW5kZSBwcm8gQW5hbHlzZScsIE1hdGgucm91bmQoZGF0YS5jcm9zc1N1cmZhY2VBbmFseXNpcy50b3RhbEJlZnVuZGUgLyBkYXRhLnByb2plY3RJbmZvLnRvdGFsQW5hbHlzZXMgKiAxMDApIC8gMTAwXSxcclxuICAgIFsnJ10sXHJcbiAgICBbJ1ZFUldFTkRFVEUgVEVDSE5PTE9HSUVOJ10sXHJcbiAgICBbJ1Byb21wdC1WYXJpYW50ZW4nLCBkYXRhLnByb2plY3RTdGF0cy5wcm9tcHRWYXJpYW50c1VzZWQuam9pbignLCAnKV0sXHJcbiAgICBbJ0xMTS1Nb2RlbGxlJywgZGF0YS5wcm9qZWN0U3RhdHMubGxtTW9kZWxzVXNlZC5qb2luKCcsICcpXVxyXG4gIF07XHJcbiAgXHJcbiAgY29uc3Qgb3ZlcnZpZXdXUyA9IFhMU1gudXRpbHMuYW9hX3RvX3NoZWV0KG92ZXJ2aWV3RGF0YSk7XHJcbiAgb3ZlcnZpZXdXU1snIWNvbHMnXSA9IFt7IHdjaDogMzAgfSwgeyB3Y2g6IDYwIH1dO1xyXG4gIFhMU1gudXRpbHMuYm9va19hcHBlbmRfc2hlZXQod29ya2Jvb2ssIG92ZXJ2aWV3V1MsICfwn5OKIFByb2pla3Qtw5xiZXJzaWNodCcpO1xyXG4gIFxyXG4gIC8vID09PSAyLiBQUk9KRUtULUtPTlRFWFQgKE5FVSkgPT09XHJcbiAgY29uc3QgY29udGV4dERhdGEgPSBbXHJcbiAgICBbJ1BST0pFS1QtS09OVEVYVCAmIEVJTkdBQkVOJ10sXHJcbiAgICBbJyddLFxyXG4gICAgWydLT05URVhULUlORk9STUFUSU9ORU4gQVVTIEFMTEVOIEFOQUxZU0VOJ11cclxuICBdO1xyXG4gIFxyXG4gIC8vIFNhbW1sZSBhbGxlIGVpbnppZ2FydGlnZW4gS29udGV4dC1JbmZvcm1hdGlvbmVuXHJcbiAgY29uc3QgYWxsQXBwT3ZlcnZpZXdzID0gWy4uLm5ldyBTZXQoZGF0YS5hbmFseXNlcy5tYXAoYSA9PiBhLmFuYWx5c2lzRGF0YS5hcHBPdmVydmlldykuZmlsdGVyKEJvb2xlYW4pKV07XHJcbiAgY29uc3QgYWxsVXNlclRhc2tzID0gWy4uLm5ldyBTZXQoZGF0YS5hbmFseXNlcy5tYXAoYSA9PiBhLmFuYWx5c2lzRGF0YS5iZW51dHplckF1ZmdhYmUpLmZpbHRlcihCb29sZWFuKSldO1xyXG4gIGNvbnN0IGFsbENvZGVJbnB1dHMgPSBbLi4ubmV3IFNldChkYXRhLmFuYWx5c2VzLm1hcChhID0+IGEuYW5hbHlzaXNEYXRhLmVpbmdlZ2ViZW5lckNvZGUpLmZpbHRlcihjb2RlID0+IGNvZGUgJiYgY29kZSAhPT0gJ0tlaW4gQ29kZSBlaW5nZWdlYmVuJykpXTtcclxuICBcclxuICAvLyBBcHAtw5xiZXJzaWNodGVuIGhpbnp1ZsO8Z2VuXHJcbiAgaWYgKGFsbEFwcE92ZXJ2aWV3cy5sZW5ndGggPiAwKSB7XHJcbiAgICBjb250ZXh0RGF0YS5wdXNoKFsnJ10sIFsnQVBQLcOcQkVSU0lDSFRFTiddKTtcclxuICAgIGFsbEFwcE92ZXJ2aWV3cy5mb3JFYWNoKChvdmVydmlldywgaW5kZXgpID0+IHtcclxuICAgICAgY29udGV4dERhdGEucHVzaChbYEFwcC3DnGJlcnNpY2h0ICR7aW5kZXggKyAxfWAsIG92ZXJ2aWV3XSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgXHJcbiAgLy8gQmVudXR6ZXJhdWZnYWJlbiBoaW56dWbDvGdlblxyXG4gIGlmIChhbGxVc2VyVGFza3MubGVuZ3RoID4gMCkge1xyXG4gICAgY29udGV4dERhdGEucHVzaChbJyddLCBbJ0JFTlVUWkVSQVVGR0FCRU4nXSk7XHJcbiAgICBhbGxVc2VyVGFza3MuZm9yRWFjaCgodGFzaywgaW5kZXgpID0+IHtcclxuICAgICAgY29udGV4dERhdGEucHVzaChbYEJlbnV0emVyYXVmZ2FiZSAke2luZGV4ICsgMX1gLCB0YXNrXSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgXHJcbiAgLy8gQ29kZS1FaW5nYWJlbiBoaW56dWbDvGdlblxyXG4gIGlmIChhbGxDb2RlSW5wdXRzLmxlbmd0aCA+IDApIHtcclxuICAgIGNvbnRleHREYXRhLnB1c2goWycnXSwgWydRVUVMTENPREUtRUlOR0FCRU4nXSk7XHJcbiAgICBhbGxDb2RlSW5wdXRzLmZvckVhY2goKGNvZGUsIGluZGV4KSA9PiB7XHJcbiAgICAgIGNvbnRleHREYXRhLnB1c2goW2BDb2RlLUVpbmdhYmUgJHtpbmRleCArIDF9YCwgY29kZV0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIEZhbGxzIGtlaW5lIEtvbnRleHRkYXRlbiB2b3JoYW5kZW5cclxuICBpZiAoYWxsQXBwT3ZlcnZpZXdzLmxlbmd0aCA9PT0gMCAmJiBhbGxVc2VyVGFza3MubGVuZ3RoID09PSAwICYmIGFsbENvZGVJbnB1dHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICBjb250ZXh0RGF0YS5wdXNoKFsnJ10sIFsnSGlud2VpcycsICdLZWluZSBzcGV6aWZpc2NoZW4gS29udGV4dC1FaW5nYWJlbiBpbiBkZW4gQW5hbHlzZW4gZ2VmdW5kZW4uJ10pO1xyXG4gIH1cclxuICBcclxuICBjb25zdCBjb250ZXh0V1MgPSBYTFNYLnV0aWxzLmFvYV90b19zaGVldChjb250ZXh0RGF0YSk7XHJcbiAgY29udGV4dFdTWychY29scyddID0gW3sgd2NoOiAyNSB9LCB7IHdjaDogMTAwIH1dOyAvLyBMYWJlbC1TcGFsdGUgdW5kIGJyZWl0ZSBJbmhhbHQtU3BhbHRlXHJcbiAgWExTWC51dGlscy5ib29rX2FwcGVuZF9zaGVldCh3b3JrYm9vaywgY29udGV4dFdTLCAn8J+TiyBQcm9qZWt0LUtvbnRleHQnKTtcclxuICBcclxuICAvLyA9PT0gMy4gQ1JPU1MtU1VSRkFDRSBBTkFMWVNFID09PVxyXG4gIGNvbnN0IGNyb3NzRGF0YSA9IFtcclxuICAgIFsnQ1JPU1MtU1VSRkFDRSBBTkFMWVNFJ10sXHJcbiAgICBbJyddLFxyXG4gICAgWydIw4RVRklHRSBQUk9CTEVNRSDDnEJFUiBBTExFIE9CRVJGTMOEQ0hFTiddLFxyXG4gICAgWydQcm9ibGVtLVR5cCcsICdIw6R1Zmlna2VpdCcsICdCZXRyb2ZmZW5lIE9iZXJmbMOkY2hlbicsICdIw6R1Zmlnc3RlciBTY2h3ZXJlZ3JhZCddXHJcbiAgXTtcclxuICBcclxuICBkYXRhLmNyb3NzU3VyZmFjZUFuYWx5c2lzLmNvbW1vblByb2JsZW1zLmZvckVhY2gocHJvYmxlbSA9PiB7XHJcbiAgICBjcm9zc0RhdGEucHVzaChbXHJcbiAgICAgIHByb2JsZW0ucHJvYmxlbSxcclxuICAgICAgcHJvYmxlbS5vY2N1cnJlbmNlcy50b1N0cmluZygpLFxyXG4gICAgICBwcm9ibGVtLnN1cmZhY2VzLmpvaW4oJywgJyksXHJcbiAgICAgIHByb2JsZW0uc2V2ZXJpdHlcclxuICAgIF0pO1xyXG4gIH0pO1xyXG4gIFxyXG4gIGNyb3NzRGF0YS5wdXNoKFxyXG4gICAgWycnXSxcclxuICAgIFsnU0NIV0VSRUdSQUQtVkVSVEVJTFVORyAoR0VTQU1UKSddLFxyXG4gICAgWydTY2h3ZXJlZ3JhZCcsICdBbnphaGwnLCAnUHJvemVudCddXHJcbiAgKTtcclxuICBcclxuICBjb25zdCB0b3RhbEJlZnVuZGUgPSBkYXRhLmNyb3NzU3VyZmFjZUFuYWx5c2lzLnRvdGFsQmVmdW5kZTtcclxuICBPYmplY3QuZW50cmllcyhkYXRhLmNyb3NzU3VyZmFjZUFuYWx5c2lzLnNldmVyaXR5RGlzdHJpYnV0aW9uKS5mb3JFYWNoKChbc2V2ZXJpdHksIGNvdW50XSkgPT4ge1xyXG4gICAgY29uc3QgcGVyY2VudCA9IHRvdGFsQmVmdW5kZSA+IDAgPyAoKGNvdW50IC8gdG90YWxCZWZ1bmRlKSAqIDEwMCkudG9GaXhlZCgxKSA6ICcwJztcclxuICAgIGNyb3NzRGF0YS5wdXNoKFtzZXZlcml0eSwgY291bnQudG9TdHJpbmcoKSwgYCR7cGVyY2VudH0lYF0pO1xyXG4gIH0pO1xyXG4gIFxyXG4gIGNvbnN0IGNyb3NzV1MgPSBYTFNYLnV0aWxzLmFvYV90b19zaGVldChjcm9zc0RhdGEpO1xyXG4gIGNyb3NzV1NbJyFjb2xzJ10gPSBbeyB3Y2g6IDMwIH0sIHsgd2NoOiAxNSB9LCB7IHdjaDogNDAgfSwgeyB3Y2g6IDIwIH1dO1xyXG4gIFhMU1gudXRpbHMuYm9va19hcHBlbmRfc2hlZXQod29ya2Jvb2ssIGNyb3NzV1MsICfwn5SNIENyb3NzLVN1cmZhY2UgQW5hbHlzZScpO1xyXG4gIFxyXG4gIC8vID09PSA0LiBPQkVSRkzDhENIRU4tVkVSR0xFSUNIID09PVxyXG4gIGNvbnN0IGNvbXBhcmlzb25EYXRhID0gW1xyXG4gICAgWydPQkVSRkzDhENIRU4tVkVSR0xFSUNIJ10sXHJcbiAgICBbJyddLFxyXG4gICAgWydPYmVyZmzDpGNoZScsICdUeXAnLCAnQmVmdW5kZSAoR2VzYW10KScsICdLcml0aXNjaGUgUHJvYmxlbWUnLCAnw5ggU2Nod2VyZWdyYWQnXVxyXG4gIF07XHJcbiAgXHJcbiAgZGF0YS5jcm9zc1N1cmZhY2VBbmFseXNpcy5zdXJmYWNlQ29tcGFyaXNvbi5mb3JFYWNoKHN1cmZhY2UgPT4ge1xyXG4gICAgY29tcGFyaXNvbkRhdGEucHVzaChbXHJcbiAgICAgIHN1cmZhY2Uuc3VyZmFjZU5hbWUsXHJcbiAgICAgIHN1cmZhY2Uuc3VyZmFjZVR5cGUsXHJcbiAgICAgIHN1cmZhY2UuYmVmdW5kZUNvdW50LnRvU3RyaW5nKCksXHJcbiAgICAgIHN1cmZhY2UuY3JpdGljYWxJc3N1ZXMudG9TdHJpbmcoKSxcclxuICAgICAgc3VyZmFjZS5hdmVyYWdlU2V2ZXJpdHlcclxuICAgIF0pO1xyXG4gIH0pO1xyXG4gIFxyXG4gIGNvbnN0IGNvbXBhcmlzb25XUyA9IFhMU1gudXRpbHMuYW9hX3RvX3NoZWV0KGNvbXBhcmlzb25EYXRhKTtcclxuICBjb21wYXJpc29uV1NbJyFjb2xzJ10gPSBbeyB3Y2g6IDMwIH0sIHsgd2NoOiAxNSB9LCB7IHdjaDogMTUgfSwgeyB3Y2g6IDE4IH0sIHsgd2NoOiAxNSB9XTtcclxuICBYTFNYLnV0aWxzLmJvb2tfYXBwZW5kX3NoZWV0KHdvcmtib29rLCBjb21wYXJpc29uV1MsICfwn5OIIE9iZXJmbMOkY2hlbi1WZXJnbGVpY2gnKTtcclxuICBcclxuICAvLyA9PT0gNS4gQUxMRSBCRUZVTkRFIEtPTlNPTElESUVSVCA9PT1cclxuICBjb25zdCBiZWZ1bmRlRGF0YSA9IFtcclxuICAgIFsnQUxMRSBCRUZVTkRFIChLT05TT0xJRElFUlQpJ10sXHJcbiAgICBbJyddLFxyXG4gICAgWydPYmVyZmzDpGNoZScsICdUeXAnLCAnQmVmdW5kLUlEJywgJ0thdGVnb3JpZScsICdTY2h3ZXJlZ3JhZCcsICdUaXRlbCcsICdCZXNjaHJlaWJ1bmcnXVxyXG4gIF07XHJcbiAgXHJcbiAgZGF0YS5hbmFseXNlcy5mb3JFYWNoKGFuYWx5c2lzID0+IHtcclxuICAgIGFuYWx5c2lzLmFuYWx5c2lzRGF0YS5iZWZ1bmRlLmZvckVhY2goYmVmdW5kID0+IHtcclxuICAgICAgYmVmdW5kZURhdGEucHVzaChbXHJcbiAgICAgICAgYW5hbHlzaXMuc3VyZmFjZU5hbWUsXHJcbiAgICAgICAgYW5hbHlzaXMuc3VyZmFjZVR5cGUsXHJcbiAgICAgICAgYmVmdW5kLmJlZnVuZElkLFxyXG4gICAgICAgIGJlZnVuZC5rYXRlZ29yaWUsXHJcbiAgICAgICAgYmVmdW5kLnNjaHdlcmVncmFkLFxyXG4gICAgICAgIGJlZnVuZC50aXRlbCxcclxuICAgICAgICBiZWZ1bmQuYmVzY2hyZWlidW5nXHJcbiAgICAgIF0pO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbiAgXHJcbiAgY29uc3QgYmVmdW5kZVdTID0gWExTWC51dGlscy5hb2FfdG9fc2hlZXQoYmVmdW5kZURhdGEpO1xyXG4gIGJlZnVuZGVXU1snIWNvbHMnXSA9IFtcclxuICAgIHsgd2NoOiAyNSB9LCAvLyBPYmVyZmzDpGNoZVxyXG4gICAgeyB3Y2g6IDEyIH0sIC8vIFR5cFxyXG4gICAgeyB3Y2g6IDI1IH0sIC8vIEJlZnVuZC1JRFxyXG4gICAgeyB3Y2g6IDE1IH0sIC8vIEthdGVnb3JpZVxyXG4gICAgeyB3Y2g6IDE1IH0sIC8vIFNjaHdlcmVncmFkXHJcbiAgICB7IHdjaDogMzAgfSwgLy8gVGl0ZWxcclxuICAgIHsgd2NoOiA4MCB9ICAvLyBCZXNjaHJlaWJ1bmdcclxuICBdO1xyXG4gIFhMU1gudXRpbHMuYm9va19hcHBlbmRfc2hlZXQod29ya2Jvb2ssIGJlZnVuZGVXUywgJ/Cfk4sgQWxsZSBCZWZ1bmRlJyk7XHJcbiAgXHJcbiAgLy8gPT09IDUuIEVJTlpFTE5FIEFOQUxZU0VOIChhbHMgc2VwYXJhdGUgU2hlZXRzKSA9PT1cclxuICBkYXRhLmFuYWx5c2VzLmZvckVhY2goKGFuYWx5c2lzLCBpbmRleCkgPT4ge1xyXG4gICAgY29uc3QgYW5hbHlzaXNEYXRhID0gW1xyXG4gICAgICBbYEFOQUxZU0U6ICR7YW5hbHlzaXMuc3VyZmFjZU5hbWV9YF0sXHJcbiAgICAgIFsnJ10sXHJcbiAgICAgIFsnTUVUQS1JTkZPUk1BVElPTkVOJ10sXHJcbiAgICAgIFsnT2JlcmZsw6RjaGUnLCBhbmFseXNpcy5zdXJmYWNlTmFtZV0sXHJcbiAgICAgIFsnVHlwJywgYW5hbHlzaXMuc3VyZmFjZVR5cGVdLFxyXG4gICAgICBbJ0thdGVnb3JpZScsIGFuYWx5c2lzLnN1cmZhY2VDYXRlZ29yeV0sXHJcbiAgICAgIFsnRXJzdGVsbHQgYW0nLCBhbmFseXNpcy5jcmVhdGVkQXQudG9Mb2NhbGVEYXRlU3RyaW5nKCdkZS1ERScpXSxcclxuICAgICAgWydUYWdzJywgYW5hbHlzaXMudGFncy5qb2luKCcsICcpXSxcclxuICAgICAgWycnXSxcclxuICAgICAgWydBTkFMWVNFLURFVEFJTFMnXSxcclxuICAgICAgWydUaXRlbCcsIGFuYWx5c2lzLmFuYWx5c2lzRGF0YS50aXRlbF0sXHJcbiAgICAgIFsnUHJvbXB0LVZhcmlhbnRlJywgYW5hbHlzaXMuYW5hbHlzaXNEYXRhLnByb21wdFZhcmlhbnRlXSxcclxuICAgICAgWydMTE0tTW9kZWxsJywgYW5hbHlzaXMuYW5hbHlzaXNEYXRhLmxsbU1vZGVsbF0sXHJcbiAgICAgIFsnVmVyYXJiZWl0dW5nc3plaXQgKG1zKScsIGFuYWx5c2lzLmFuYWx5c2lzRGF0YS52ZXJhcmJlaXR1bmdzemVpdF0sXHJcbiAgICAgIFsnJ10sXHJcbiAgICAgIFsnQkVGVU5ERSddLFxyXG4gICAgICBbJ0JlZnVuZC1JRCcsICdLYXRlZ29yaWUnLCAnU2Nod2VyZWdyYWQnLCAnVGl0ZWwnLCAnQmVzY2hyZWlidW5nJ11cclxuICAgIF07XHJcbiAgICBcclxuICAgIGFuYWx5c2lzLmFuYWx5c2lzRGF0YS5iZWZ1bmRlLmZvckVhY2goYmVmdW5kID0+IHtcclxuICAgICAgYW5hbHlzaXNEYXRhLnB1c2goW1xyXG4gICAgICAgIGJlZnVuZC5iZWZ1bmRJZCxcclxuICAgICAgICBiZWZ1bmQua2F0ZWdvcmllLFxyXG4gICAgICAgIGJlZnVuZC5zY2h3ZXJlZ3JhZCxcclxuICAgICAgICBiZWZ1bmQudGl0ZWwsXHJcbiAgICAgICAgYmVmdW5kLmJlc2NocmVpYnVuZ1xyXG4gICAgICBdKTtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBjb25zdCBhbmFseXNpc1dTID0gWExTWC51dGlscy5hb2FfdG9fc2hlZXQoYW5hbHlzaXNEYXRhKTtcclxuICAgIGFuYWx5c2lzV1NbJyFjb2xzJ10gPSBbXHJcbiAgICAgIHsgd2NoOiAyNSB9LCAvLyBCZWZ1bmQtSURcclxuICAgICAgeyB3Y2g6IDE1IH0sIC8vIEthdGVnb3JpZVxyXG4gICAgICB7IHdjaDogMTUgfSwgLy8gU2Nod2VyZWdyYWRcclxuICAgICAgeyB3Y2g6IDMwIH0sIC8vIFRpdGVsXHJcbiAgICAgIHsgd2NoOiA4MCB9ICAvLyBCZXNjaHJlaWJ1bmdcclxuICAgIF07XHJcbiAgICBcclxuICAgIC8vIFNoZWV0LU5hbWUga8O8cnplbiBmYWxscyBuw7Z0aWcgKEV4Y2VsLUxpbWl0OiAzMSBaZWljaGVuKVxyXG4gICAgY29uc3Qgc2hlZXROYW1lID0gYW5hbHlzaXMuc3VyZmFjZU5hbWUubGVuZ3RoID4gMjUgXHJcbiAgICAgID8gYCR7YW5hbHlzaXMuc3VyZmFjZU5hbWUuc3Vic3RyaW5nKDAsIDIyKX0uLi5gXHJcbiAgICAgIDogYW5hbHlzaXMuc3VyZmFjZU5hbWU7XHJcbiAgICBcclxuICAgIFhMU1gudXRpbHMuYm9va19hcHBlbmRfc2hlZXQod29ya2Jvb2ssIGFuYWx5c2lzV1MsIGAke2luZGV4ICsgMX0uICR7c2hlZXROYW1lfWApO1xyXG4gIH0pO1xyXG4gIFxyXG4gIGNvbnNvbGUubG9nKGDinIUgQWdncmVnYXRlZCBFeGNlbCBtaXQgJHt3b3JrYm9vay5TaGVldE5hbWVzLmxlbmd0aH0gQXJiZWl0c2Jsw6R0dGVybiBlcnN0ZWxsdGApO1xyXG4gIHJldHVybiB3b3JrYm9vaztcclxufVxyXG5cclxuLy8g8J+agCBNYWluIEV4cG9ydCBGdW5jdGlvblxyXG5leHBvcnQgZnVuY3Rpb24gZXhwb3J0QWdncmVnYXRlZEV4Y2VsKHByb2plY3RJZDogc3RyaW5nKTogdm9pZCB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKGDwn5qAIFN0YXJ0ZSBBZ2dyZWdhdGVkIEV4Y2VsIEV4cG9ydCBmw7xyIFByb2pla3QgJHtwcm9qZWN0SWR9Li4uYCk7XHJcbiAgICBcclxuICAgIC8vIFByb2pla3QtRGF0ZW4gYW5hbHlzaWVyZW5cclxuICAgIGNvbnN0IGFnZ3JlZ2F0ZWREYXRhID0gQ3Jvc3NTdXJmYWNlQW5hbHl6ZXIuYW5hbHl6ZVByb2plY3QocHJvamVjdElkKTtcclxuICAgIFxyXG4gICAgLy8gRXhjZWwtV29ya2Jvb2sgZXJzdGVsbGVuXHJcbiAgICBjb25zdCB3b3JrYm9vayA9IGNyZWF0ZUFnZ3JlZ2F0ZWRFeGNlbFdvcmtib29rKGFnZ3JlZ2F0ZWREYXRhKTtcclxuICAgIFxyXG4gICAgLy8gRGF0ZWluYW1lIGdlbmVyaWVyZW5cclxuICAgIGNvbnN0IHNhZmVQcm9qZWN0TmFtZSA9IGFnZ3JlZ2F0ZWREYXRhLnByb2plY3RJbmZvLnByb2plY3ROYW1lLnJlcGxhY2UoL1teYS16QS1aMC05XS9nLCAnXycpO1xyXG4gICAgY29uc3QgZmlsZW5hbWUgPSBgUHJvamVrdF8ke3NhZmVQcm9qZWN0TmFtZX1fQWdncmVnYXRlZF8ke2FnZ3JlZ2F0ZWREYXRhLnByb2plY3RJbmZvLmV4cG9ydElkfS54bHN4YDtcclxuICAgIFxyXG4gICAgLy8gRG93bmxvYWQgc3RhcnRlblxyXG4gICAgY29uc3QgZXhjZWxCdWZmZXIgPSBYTFNYLndyaXRlKHdvcmtib29rLCB7IFxyXG4gICAgICBib29rVHlwZTogJ3hsc3gnLCBcclxuICAgICAgdHlwZTogJ2FycmF5JyxcclxuICAgICAgY29tcHJlc3Npb246IHRydWUgXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtleGNlbEJ1ZmZlcl0sIHsgXHJcbiAgICAgIHR5cGU6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5zaGVldCcgXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XHJcbiAgICBsaW5rLmhyZWYgPSB1cmw7XHJcbiAgICBsaW5rLmRvd25sb2FkID0gZmlsZW5hbWU7XHJcbiAgICBsaW5rLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICBcclxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGluayk7XHJcbiAgICBsaW5rLmNsaWNrKCk7XHJcbiAgICBcclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGxpbmspO1xyXG4gICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XHJcbiAgICB9LCAxMDApO1xyXG4gICAgXHJcbiAgICAvLyBFcmZvbGdzLUZlZWRiYWNrXHJcbiAgICBhbGVydChg8J+OryBBZ2dyZWdhdGVkIEV4Y2VsIEV4cG9ydCBlcmZvbGdyZWljaCFcXG5cXG5gICtcclxuICAgICAgICAgIGBQcm9qZWt0OiAke2FnZ3JlZ2F0ZWREYXRhLnByb2plY3RJbmZvLnByb2plY3ROYW1lfVxcbmAgK1xyXG4gICAgICAgICAgYERhdGVpOiAke2ZpbGVuYW1lfVxcblxcbmAgK1xyXG4gICAgICAgICAgYEluaGFsdDpcXG5gICtcclxuICAgICAgICAgIGDigKIgJHthZ2dyZWdhdGVkRGF0YS5wcm9qZWN0SW5mby50b3RhbEFuYWx5c2VzfSBBbmFseXNlblxcbmAgK1xyXG4gICAgICAgICAgYOKAoiAke2FnZ3JlZ2F0ZWREYXRhLmNyb3NzU3VyZmFjZUFuYWx5c2lzLnRvdGFsQmVmdW5kZX0gQmVmdW5kZVxcbmAgK1xyXG4gICAgICAgICAgYOKAoiAke3dvcmtib29rLlNoZWV0TmFtZXMubGVuZ3RofSBBcmJlaXRzYmzDpHR0ZXJcXG5gICtcclxuICAgICAgICAgIGDigKIgQ3Jvc3MtU3VyZmFjZSBBbmFseXNlXFxuYCArXHJcbiAgICAgICAgICBg4oCiIFRyZW5kLUFuYWx5c2VcXG5cXG5gICtcclxuICAgICAgICAgIGBEaWUgRGF0ZWkgd3VyZGUgaGVydW50ZXJnZWxhZGVuLmApO1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZyhg4pyFIEFnZ3JlZ2F0ZWQgRXhjZWwgRXhwb3J0IGFiZ2VzY2hsb3NzZW46ICR7ZmlsZW5hbWV9YCk7XHJcbiAgICBcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcign4p2MIEFnZ3JlZ2F0ZWQgRXhjZWwgRXhwb3J0IEZlaGxlcjonLCBlcnJvcik7XHJcbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmJla2FubnRlciBGZWhsZXInO1xyXG4gICAgYWxlcnQoYOKdjCBBZ2dyZWdhdGVkIEV4Y2VsIEV4cG9ydCBmZWhsZ2VzY2hsYWdlbiFcXG5cXG5GZWhsZXI6ICR7ZXJyb3JNZXNzYWdlfWApO1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsiWExTWCIsIlByb2plY3RNYW5hZ2VyIiwiQ3Jvc3NTdXJmYWNlQW5hbHl6ZXIiLCJhbmFseXplUHJvamVjdCIsInByb2plY3RJZCIsImRhdGVzIiwicHJvamVjdCIsImdldFByb2plY3QiLCJhbmFseXNlcyIsImdldEFuYWx5c2VzQnlQcm9qZWN0IiwibGVuZ3RoIiwiRXJyb3IiLCJjb25zb2xlIiwibG9nIiwicHJvamVjdE5hbWUiLCJjcm9zc0FuYWx5c2lzIiwicGVyZm9ybUNyb3NzU3VyZmFjZUFuYWx5c2lzIiwicHJvamVjdFN0YXRzIiwiY2FsY3VsYXRlUHJvamVjdFN0YXRzIiwibWFwIiwiYSIsImNyZWF0ZWRBdCIsInNvcnQiLCJiIiwiZ2V0VGltZSIsImRhdGVSYW5nZSIsImVhcmxpZXN0IiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwibGF0ZXN0IiwiZXhwb3J0SWQiLCJNYXRoIiwiRGF0ZSIsIm5vdyIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwidG9VcHBlckNhc2UiLCJwcm9qZWN0SW5mbyIsInByb2plY3REZXNjcmlwdGlvbiIsInRvdGFsQW5hbHlzZXMiLCJleHBvcnREYXRlIiwiY3Jvc3NTdXJmYWNlQW5hbHlzaXMiLCJhbGxCZWZ1bmRlIiwiZmxhdE1hcCIsImFuYWx5c2lzIiwiYW5hbHlzaXNEYXRhIiwiYmVmdW5kZSIsImJlZnVuZCIsInN1cmZhY2VOYW1lIiwic3VyZmFjZVR5cGUiLCJhbmFseXNpc0lkIiwiY29tbW9uUHJvYmxlbXMiLCJkZXRlY3RDb21tb25Qcm9ibGVtcyIsInNldmVyaXR5RGlzdHJpYnV0aW9uIiwicmVkdWNlIiwiYWNjIiwic2Nod2VyZWdyYWQiLCJzdXJmYWNlQ29tcGFyaXNvbiIsImNvbXBhcmVTdXJmYWNlcyIsInRyZW5kcyIsImFuYWx5emVUcmVuZHMiLCJ0b3RhbEJlZnVuZGUiLCJwcm9ibGVtR3JvdXBzIiwia2V5d29yZHMiLCJmb3JFYWNoIiwidGV4dCIsInRpdGVsIiwiYmVzY2hyZWlidW5nIiwidG9Mb3dlckNhc2UiLCJmb3VuZEtleXdvcmRzIiwiZmlsdGVyIiwia2V5d29yZCIsImluY2x1ZGVzIiwicHJpbWFyeUtleXdvcmQiLCJwdXNoIiwiT2JqZWN0IiwiZW50cmllcyIsImdyb3VwIiwicHJvYmxlbSIsImNoYXJBdCIsInNsaWNlIiwib2NjdXJyZW5jZXMiLCJzdXJmYWNlcyIsIlNldCIsInNldmVyaXR5IiwiZ2V0TW9zdENvbW1vblNldmVyaXR5Iiwic2V2ZXJpdHlDb3VudHMiLCJjcml0aWNhbElzc3VlcyIsInNldmVyaXR5U2NvcmVzIiwiYXZnU2NvcmUiLCJzdW0iLCJhdmdTZXZlcml0eSIsImJlZnVuZGVDb3VudCIsImF2ZXJhZ2VTZXZlcml0eSIsInNvcnRlZEFuYWx5c2VzIiwiaW1wcm92aW5nQXJlYXMiLCJ3b3JzZW5pbmdBcmVhcyIsImVhcmx5IiwiY2VpbCIsInJlY2VudCIsImZsb29yIiwiZWFybHlDcml0aWNhbCIsInJlY2VudENyaXRpY2FsIiwicHJvbXB0VmFyaWFudHMiLCJwcm9tcHRWYXJpYW50ZSIsImxsbU1vZGVscyIsImxsbU1vZGVsbCIsInN1cmZhY2VUeXBlcyIsInN1cmZhY2VDYXRlZ29yaWVzIiwic3VyZmFjZUNhdGVnb3J5IiwidG90YWxQcm9jZXNzaW5nVGltZSIsInZlcmFyYmVpdHVuZ3N6ZWl0IiwiYW5hbHlzaXNFZmZpY2llbmN5Iiwicm91bmQiLCJwcm9tcHRWYXJpYW50c1VzZWQiLCJsbG1Nb2RlbHNVc2VkIiwiY3JlYXRlQWdncmVnYXRlZEV4Y2VsV29ya2Jvb2siLCJkYXRhIiwid29ya2Jvb2siLCJ1dGlscyIsImJvb2tfbmV3Iiwib3ZlcnZpZXdEYXRhIiwiam9pbiIsIm92ZXJ2aWV3V1MiLCJhb2FfdG9fc2hlZXQiLCJ3Y2giLCJib29rX2FwcGVuZF9zaGVldCIsImNvbnRleHREYXRhIiwiYWxsQXBwT3ZlcnZpZXdzIiwiYXBwT3ZlcnZpZXciLCJCb29sZWFuIiwiYWxsVXNlclRhc2tzIiwiYmVudXR6ZXJBdWZnYWJlIiwiYWxsQ29kZUlucHV0cyIsImVpbmdlZ2ViZW5lckNvZGUiLCJjb2RlIiwib3ZlcnZpZXciLCJpbmRleCIsInRhc2siLCJjb250ZXh0V1MiLCJjcm9zc0RhdGEiLCJjb3VudCIsInBlcmNlbnQiLCJ0b0ZpeGVkIiwiY3Jvc3NXUyIsImNvbXBhcmlzb25EYXRhIiwic3VyZmFjZSIsImNvbXBhcmlzb25XUyIsImJlZnVuZGVEYXRhIiwiYmVmdW5kSWQiLCJrYXRlZ29yaWUiLCJiZWZ1bmRlV1MiLCJ0YWdzIiwiYW5hbHlzaXNXUyIsInNoZWV0TmFtZSIsIlNoZWV0TmFtZXMiLCJleHBvcnRBZ2dyZWdhdGVkRXhjZWwiLCJhZ2dyZWdhdGVkRGF0YSIsInNhZmVQcm9qZWN0TmFtZSIsInJlcGxhY2UiLCJmaWxlbmFtZSIsImV4Y2VsQnVmZmVyIiwid3JpdGUiLCJib29rVHlwZSIsInR5cGUiLCJjb21wcmVzc2lvbiIsImJsb2IiLCJCbG9iIiwidXJsIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwibGluayIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImhyZWYiLCJkb3dubG9hZCIsInN0eWxlIiwiZGlzcGxheSIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImNsaWNrIiwic2V0VGltZW91dCIsInJlbW92ZUNoaWxkIiwicmV2b2tlT2JqZWN0VVJMIiwiYWxlcnQiLCJlcnJvciIsImVycm9yTWVzc2FnZSIsIm1lc3NhZ2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/aggregatedExport.ts\n"));

/***/ })

});